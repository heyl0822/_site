<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico?">
  <title>Learn C++ Ch4 Variable Scope and More Types</title>
  <meta name="description" content="Blocks (compound statements)">

  <link rel="stylesheet" href="/_site/css/main.css">
  <link rel="canonical" href="http://heyl0822.github.io//_site/c++/2016/05/25/learn_c++_ch4_variable_scope_and_more_types.html">
  <link rel="alternate" type="application/rss+xml" title="Yanling's Blog" href="http://heyl0822.github.io//_site/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

	  
	
	<ul class="main-site">
    	<li>
            <a href="/_site"><span class="logo"><?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 19.2.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 1000 1000" style="enable-background:new 0 0 1000 1000;" xml:space="preserve">
	<style type="text/css">
		.st0{opacity:0;}
		.st1{fill:#010101;}
		.st2{font-family:'HelveticaNeue';}
		.st3{font-size:100px;}
		.st4{fill:none;}
		.st5{font-family:'Helvetica-Bold';}
		.st6{font-size:500px;}
		.st7{font-size:80px;}
	</style>
	<g id="Layer_0_xA0_Image_1_" class="st0">

		<image style="overflow:visible;" width="1000" height="1000" id="Layer_0_xA0_Image" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+gAAAPoCAIAAADCwUOzAAAACXBIWXMAAAsSAAALEgHS3X78AAAA
		GXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAEOxJREFUeNrs1jEBAAAIwzDmX/Sw
		wMmRSOjVtB0AAOC3GHcAADDuAACAcQcAAOMOAAAYdwAAwLgDAIBxBwAAjDsAAGDcAQDAuAMAAMYd
		AACMOwAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAYdwAAwLgDAIBxBwAAjDsAABh3AADAuAMA
		AMYdAACMOwAAYNwBAADjDgAAxh0AADDuAABg3AEAAOMOAAAYdwAAMO4AAIBxBwAAjDsAABh3AADA
		uAMAAMYdAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAAAYdwAAMO4AAIBxBwAA4w4AABh3
		AADAuAMAgHEHAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAADGHQAAMO4AAIBxBwAA4w4A
		ABh3AADAuAMAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAAOMOAADGHQAAMO4AAIBxBwAA
		4w4AABh3AAAw7gAAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAwLgDAADGHQAAMO4AAGDc
		AQAA4w4AABh3AAAw7gAAgHEHAACMOwAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAAMO4A
		AGDcAQAA4w4AAMYdAAAw7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAA
		jDsAAGDcAQAA4w4AAMYdAAAw7gAAgHEHAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgDAADG
		HQAAjDsAAGDcAQAA4w4AAMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgD
		AIBxBwAAjDsAAGDcAQDAuAMAAMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAOMOAAAYdwAA
		wLgDAIBxBwAAjDsAAGDcAQDAuAMAAMYdAACMOwAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAY
		dwAAwLgDAIBxBwAAjDsAABh3AADAuAMAAMYdAACMOwAAYNwBAADjDgAAxh0AADDuAABg3AEAAOMO
		AAAYdwAAMO4AAIBxBwAAjDsAABh3AADAuAMAAMYdAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEA
		AOMOAAAYdwAAMO4AAIBxBwAA464CAAAYdwAAwLgDAIBxBwAAjDsAAGDcAQDAuAMAAMYdAAAw7gAA
		YNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAYdwAAwLgDAIBxBwAAjDsAABh34w4AAMYdAAAw7gAA
		YNwBAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgDAIBxBwAAjDsAAGDcAQDAuAMAAMYdAAAw
		7gAAYNwBAADjDgAAxt24AwCAcQcAAIw7AAAYdwAAwLgDAADGHQAAjDsAAGDcAQAA4w4AAMYdAAAw
		7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgDAIBxN+4AAGDcAQAA4w4AAMYdAAAw
		7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AAAYdwAAwLgDAADGHQAAjDsAAGDcAQAA4w4AAMYd
		AAAw7gAAgHEHAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgDAADGHQAAjDsAAGDcAQDAuAMA
		AMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgDAIBxBwAAjDsAAGDcAQDA
		uAMAAMYdAAAw7gAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAYdwAAwLgDAIBxBwAAjDsAAGDc
		AQDAuAMAAMYdAACMOwAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAYdwAAMO4AAIBxBwAAjDsA
		ABh3AADAuAMAAMYdAACMOwAAYNwBAADjDgAAxh0AADDuAABg3AEAAOMOAAAYdwAAMO4AAIBxBwAA
		jDsAABh3AADAuAMAgHEHAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAAAYdwAAMO4AAIBx
		BwAA4w4AABh3AADAuAMAgHEHAACMOwAAYNwBAMC4AwAAxh0AAIw7AABg3AEAAOMOAADGHQAAMO4A
		AIBxBwAA4w4AABh3AADAuAMAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAAOMOAADGHQAA
		MO4AAGDcAQAA4w4AABh3AAAw7gAAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAwLgDAADG
		HQAAMO4AAGDcAQAA4w4AABh3AAAw7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgD
		AADGHQAAMO4AAGDcAQAA4w4AAMYdAAAw7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AAAYdwAA
		wLgDAADGHQAAjDsAAGDcAQAA4w4AAMYdAAAw7gAAgHEHAADjDgAAGHcAADDuAACAcQcAAIw7AAAY
		dwAAwLgDAADGHQAAjDsAAGDcAQDAuAMAAMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAIw7
		AAAYdwAAwLgDAIBxBwAAjDsAAGDcAQDAuAMAAMYdAAAw7gAAYNwBAADjDgAAxl0FAAAw7gAAgHEH
		AADjDgAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAAjDsAAGDcAQAA4w4AAMYdAAAw7gAA
		gHEHAADjDgAAGHcAADDuxh0AAIw7AABg3AEAwLgDAADGHQAAMO4AAGDcAQAA4w4AABh3AAAw7gAA
		gHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAAjLtxBwAA4w4AABh3AAAw7gAA
		gHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAwLgDAADGHQAAMO4AAGDcAQAA4w4AABh3AAAw
		7gAAgHEHAADjbtwBAMC4AwAAxh0AAIw7AABg3AEAAOMOAADGHQAAMO4AAIBxBwAA4w4AABh3AAAw
		7gAAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAAOMOAADGHQAAMO4AAGDcAQAA4w4AABh3
		AAAw7gAAgHEHAACMOwAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAAMO4AAGDcAQAA4w4A
		ABh3AAAw7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAAjDsAAGDcAQAA
		4w4AAMYdAAAw7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AAAYdwAAwLgDAADGHQAAjDsAAGDc
		AQAA4w4AAMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgDAADGHQAAjDsA
		AGDcAQDAuAMAAMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAOMOAAAYdwAAwLgDAIBxBwAA
		jDsAAGDcAQDAuAMAAMYdAAAw7gAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAYdwAAwLgDAIBx
		BwAAjDsAABh3AADAuAMAAMYdAACMOwAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAYdwAAMO4A
		AIBxBwAAjDsAABh3AADAuAMAAMYdAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAAAYdwAA
		MO4AAIBxBwAAjDsAABh3AADAuAMAgHEHAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAADG
		HQAAMO4AAIBxBwAA4w4AABh3AADAuAMAgHEHAACMOwAAYNwBAMC4AwAAxh0AAIw7AABg3AEAAOMO
		AADGHQAAMO4AAIBxBwAA4w4AABh3AAAw7gAAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEA
		AOMOAADGHQAAMO4AAGDcAQAA4w4AABh3AAAw7gAAgHEHAACMOwAAGHcAAMC4AwCAcQcAAIw7AABg
		3AEAwLgDAADGHQAAMO4AAGDcAQAA4w4AABh3AAAw7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7
		AABg3AEAwLgDAADGHQAAjLsKAABg3AEAAOMOAADGHQAAMO4AAIBxBwAA4w4AABh3AADAuAMAgHEH
		AACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAAOMOAADGHQAAMO4AAGDcjTsAABh3AADAuAMAgHEH
		AACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAADGHQAAMO4AAIBxBwAA4w4AABh3AADAuAMA
		gHEHAACMOwAAGHfjDgAAxh0AADDuAABg3AEAAOMOAAAYdwAAMO4AAIBxBwAAjDsAABh3AADAuAMA
		gHEHAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAADG3bgDAIBxBwAAjDsAABh3AADAuAMA
		AMYdAACMOwAAYNwBAADjDgAAxh0AADDuAABg3AEAAOMOAAAYdwAAMO4AAIBxBwAAjDsAABh3AADA
		uAMAAMYdAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAAAYdwAAMO4AAIBxBwAA4w4AABh3
		AADAuAMAgHEHAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEAAOMOAADGHQAAMO4AAIBxBwAA4w4A
		ABh3AADAuAMAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAAOMOAADGHQAAMO4AAIBxBwAA
		4w4AABh3AAAw7gAAgHEHAACMOwAAGHcAAMC4AwAAxh0AAIw7AABg3AEAwLgDAADGHQAAMO4AAGDc
		AQAA4w4AABh3AAAw7gAAgHEHAACMOwAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAAMO4A
		AGDcAQAA4w4AAMYdAAAw7gAAgHEHAADjDgAAGHcAAMC4AwCAcQcAAIw7AABg3AEAwLgDAADGHQAA
		jDsAAGDcAQAA4w4AAMYdAAAw7gAAgHEHAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgDAADG
		HQAAjDsAAGDcAQAA4w4AAMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAIw7AAAYdwAAwLgD
		AIBxBwAAjDsAAGDcAQDAuAMAAMYdAAAw7gAAYNwBAADjDgAAGHcAADDuAACAcQcAAOMOAAAYdwAA
		wLgDAIBxBwAAjDsAAGDcAQDAuAMAAMYdAACMOwAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAY
		dwAAwLgDAIBxBwAAjDsAABh3AADAuAMAAMYdAACMOwAAYNwBAADjDgAAxh0AADDuAABg3AEAAOMO
		AAAYdwAAMO4AAIBxBwAAjDsAABh3AADAuAMAAMYdAACMOwAAYNwBAMC4AwAAxh0AADDuAABg3AEA
		AOMOAAAYdwAAMO4AAIBxBwAA4w4AABh3AADAuAMAgHEHAACMOwAAYNwBAMC4AwAAxh0AADDuAABg
		3AEAAOMOAADGHQAAMO4AAIBxBwAA4w4AABh3AADAuAMAgHEHAACMOwAAGHcVAADAuAMAAMYdAACM
		OwAAYNwBAADjDgAAxh0AADDuAACAcQcAAOMOAAAYdwAAMO4AAIBxBwAAjDsAABh3AADAuAMAAMYd
		AACMOwAAYNwBAMC4G3cAADDuAACAcQcAAOMOAAAYdwAA4GYFGACAFLDWMjRLMwAAAABJRU5ErkJg
		gg==">
		</image>
	</g>
	<g id="Group_1_1_">
		<g id="Rectangle_1">
			<g>
				<path class="st1" d="M915,85v830H85V85H915 M925,75H75v850h850V75L925,75z"/>
			</g>
		</g>
		<g id="_x32_">
			<text transform="matrix(1 0 0 1 810.4551 194.3569)" class="st2 st3">2</text>
		</g>
		<g id="He">
			<rect x="75" y="303" class="st4" width="850" height="850"/>
			<text transform="matrix(1 0 0 1 180.4199 662.4971)" class="st5 st6">He</text>
		</g>
		<g id="Ms._He">
			<rect x="75" y="728" class="st4" width="850" height="850"/>
			<text transform="matrix(1 0 0 1 372.5616 785.1191)" class="st2 st7">Ms. He</text>
		</g>
	</g>
</svg>
</span></a>

        </li>
	</ul>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Learn C++ Ch4 Variable Scope and More Types</h1>
    <p class="post-meta"><time datetime="2016-05-25T08:08:58-07:00" itemprop="datePublished">May 25, 2016</time></p>
  </header>

  <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  <div class="post-content" itemprop="articleBody">
    <h2 id="blocks-compound-statements">Blocks (compound statements)</h2>

<p>A <strong>block</strong> of statements, also called a <strong>compound statement</strong>, is a group of statements that is treated by the compiler as if it were a single statement.</p>

<p>A variable’s <strong>scope</strong> determines where a variable is accessible.</p>

<p>A variable’s <strong>duration</strong> determines where it is created and destroyed.</p>

<p>Variables defined inside a block are called <strong>local variables</strong>. Local variables have <strong>automatic duration</strong>, which means they are created when the block they are part of is entered, and destroyed when the block they are part of is exited. Local variables have <strong>block scope</strong> (also called <strong>local scope</strong>), which means they enter scope at the point of declaration and go out of scope at the end of the block that they are defined in.</p>

<p>Note that variables inside nested blocks can have the same name as variable inside outer blocks. When this happens, the nested variable “hides” the outer variable. This is called <strong>name hiding</strong> or <strong>shadowing</strong>.</p>

<p>Rule: Define variables in the smallest scope possible.
Rule: Avoid using nested variables with the same names as variables in an outer block.</p>

<p><strong>Summary</strong></p>

<p>Variables defined inside blocks are called local variables. These variables can only be accessed inside the block in which they are defined (including nested blocks), and they are destroyed as soon as the block ends.</p>

<p>Define variables in the smallest scope that they are used. If a variable is only used within a nested block, define it within the nested block.</p>

<h2 id="global-variables-and-linkage">Global variables and linkage</h2>

<p>Variables declared outside of a block are called <strong>global variables</strong>. Global variables have <strong>static duration</strong>, which means they are created when the program starts and are destroyed when it ends. Global variables have <strong>global scope</strong> (also called “global namespace scope” or “file scope”), which means they are visible until the end of the file in which they are declared.</p>

<p><strong>Defining global variables</strong></p>

<p>global variables are declared at the top of a file, below the includes, but above any code.</p>

<p>the global scope operator (::) can be used to tell the compiler you mean the global version instead of the local version.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int g_x; // global variable g_x
const int g_y(2); // global variable g_y

int value = 7; // hides the global variable value
value++; // increments local value, not global value
::value--;
</code></pre>
</div>

<p>many developers prefix global variable names with “g_” to indicate that they are global. This both helps identify global variables as well as avoids naming conflicts with local variables.</p>

<p>A variable’s <strong>linkage</strong> determines whether multiple instances of an identifier refer to the same variable or not.</p>

<p>A variable with <strong>internal linkage</strong> is called an internal variable (or static variable). Variables with internal linkage can be used anywhere within the file they are defined in, but can not be referenced outside the file they exist in.</p>

<p>A variable with <strong>external linkage</strong> is called an external variable. Variables with external linkage can be used both in the file they are defined in, as well as in other files.</p>

<p>If we want to make a global variable internal (able to be used only within a single file), we can use the <strong>static</strong> keyword to do so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>static int g_x; // g_x is static, and can only be used within this file

int main()
{
    return 0;
}
</code></pre>
</div>

<p>if we want to make a global variable external (able to be used anywhere in our program), we can use the <strong>extern</strong> keyword to do so:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>extern double g_y(9.8); // g_y is external, and can be used by other files

int main()
{
    return 0;
}
</code></pre>
</div>

<p>By default, non-const variables declared outside of a block are assumed to be external. However, const variables declared outside of a block are assumed to be internal.</p>

<p><strong>Variable forward declarations via the extern keyword</strong></p>

<p>in order to use an external global variable that has been declared in another file, you have to use a variable forward declaration. For variables, creating a forward declaration is also done via the <strong>extern</strong> keyword.</p>

<p><strong>Summary</strong></p>

<p>Global variables have global scope, and can be used anywhere in the program. Like functions, you must use a forward declaration (via keyword extern) to use a global variable defined in another file.</p>

<p>By default, non-const global variables have external linkage. You can use the static keyword to explicitly make them internal if desired.
By default, const global variables have internal linkage. You can use the extern keyword to explicitly make them external if desired.</p>

<p>Use a g_ prefix to help identify your non-const global variables.</p>

<p>Here’s a summary chart of the use of the extern keyword for non-const and const variable use cases:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="sr">//</span> <span class="no">Uninitialized</span> <span class="ss">definition:
    </span><span class="n">int</span> <span class="n">g_x</span><span class="p">;</span>       <span class="sr">//</span> <span class="n">defines</span> <span class="n">uninitialized</span> <span class="n">global</span> <span class="n">variable</span> <span class="p">(</span><span class="n">external</span> <span class="n">linkage</span><span class="p">)</span>
    <span class="n">const</span> <span class="n">int</span> <span class="n">g_x</span><span class="p">;</span> <span class="sr">//</span> <span class="n">not</span> <span class="ss">allowed: </span><span class="n">const</span> <span class="n">variables</span> <span class="n">must</span> <span class="n">be</span> <span class="n">initialized</span>

    <span class="sr">//</span> <span class="no">Forward</span> <span class="n">declaration</span> <span class="n">via</span> <span class="n">extern</span> <span class="ss">keyword:
    </span><span class="n">extern</span> <span class="n">int</span> <span class="n">g_z</span><span class="p">;</span>       <span class="sr">//</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="k">for</span> <span class="n">global</span> <span class="n">variable</span> <span class="n">defined</span> <span class="n">elsewhere</span>
    <span class="n">extern</span> <span class="n">const</span> <span class="n">int</span> <span class="n">g_z</span><span class="p">;</span> <span class="sr">//</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="k">for</span> <span class="n">const</span> <span class="n">global</span> <span class="n">variable</span> <span class="n">defined</span> <span class="n">elsewhere</span>

    <span class="sr">//</span> <span class="no">Initialized</span> <span class="ss">definition:
    </span><span class="n">int</span> <span class="n">g_y</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>       <span class="sr">//</span> <span class="n">defines</span> <span class="n">initialized</span> <span class="n">global</span> <span class="n">variable</span> <span class="p">(</span><span class="n">external</span> <span class="n">linkage</span><span class="p">)</span>
    <span class="n">const</span> <span class="n">int</span> <span class="n">g_y</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="sr">//</span> <span class="n">defines</span> <span class="n">initialized</span> <span class="n">static</span> <span class="n">variable</span> <span class="p">(</span><span class="n">internal</span> <span class="n">linkage</span><span class="p">)</span>

    <span class="sr">//</span> <span class="no">Initialized</span> <span class="n">definition</span> <span class="n">w</span><span class="o">/</span><span class="n">extern</span> <span class="ss">keyword:
    </span><span class="n">extern</span> <span class="n">int</span> <span class="n">g_w</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>       <span class="sr">//</span> <span class="n">defines</span> <span class="n">initialized</span> <span class="n">global</span> <span class="n">variable</span> <span class="p">(</span><span class="n">external</span> <span class="n">linkage</span><span class="p">,</span> <span class="n">extern</span> <span class="n">keyword</span> <span class="n">is</span> <span class="n">redundant</span> <span class="k">in</span> <span class="n">this</span> <span class="k">case</span><span class="p">)</span>
    <span class="n">extern</span> <span class="n">const</span> <span class="n">int</span> <span class="n">g_w</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="sr">//</span> <span class="n">defines</span> <span class="n">initialized</span> <span class="n">const</span> <span class="n">global</span> <span class="n">variable</span> <span class="p">(</span><span class="n">external</span> <span class="n">linkage</span><span class="p">)</span>
    </code></pre></figure>

<p>Avoid use of non-const global variables if at all possible! If you do have to use them, use them sensibly and cautiously.</p>

<p>Const global variables (symbolic constants) are fine to use, so long as you use proper naming conventions.</p>

<h2 id="static-duration-variables">Static duration variables</h2>

<p>A <strong>static duration</strong> variable (also called a “static variable”) is one that retains its value even after the scope in which it has been created has been exited! Static duration variables are only created (and initialized) once, and then they are persisted throughout the life of the program.</p>

<h2 id="scope-duration-and-likage-summary">Scope, duration and likage summary</h2>

<p><strong>Scope summary</strong></p>

<p>A identifier’s <strong>scope</strong> determines where it is accessible. An identifier that is out of scope can not be accessed.</p>

<ul>
  <li>Variables with <strong>block scope / local scope</strong> can only be accessed within the block in which they are declared. This includes:
    <ul>
      <li>Local variables</li>
      <li>Function parameters</li>
    </ul>
  </li>
  <li>Variables with <strong>global scope / file scope</strong> can be accessed anywhere in the file. This includes:
    <ul>
      <li>Global variables</li>
    </ul>
  </li>
</ul>

<p><strong>Duration summary</strong></p>

<p>A variable’s <strong>duration</strong> determines when it is created and destroyed.</p>

<ul>
  <li>Variables with <strong>automatic duration</strong> are created when the block they are part of is entered, and destroyed when the block they are part of is exited. This includes:
    <ul>
      <li>Normal local variables</li>
    </ul>
  </li>
  <li>Variables with <strong>static duration</strong> are created when the program begins and destroyed when the program ends. This includes:
    <ul>
      <li>Global variables</li>
      <li>Static local variables</li>
    </ul>
  </li>
  <li>Variables with <strong>dynamic duration</strong> are created and destroyed by programmer request. This includes:
    <ul>
      <li>Dynamically allocated variables (we’ll talk about these when we cover dynamic allocation in chapter 6)</li>
    </ul>
  </li>
</ul>

<p><strong>Linkage summary</strong></p>

<p>An identifier’s linkage determines whether multiple instances of an identifier refer to the same identifier or not.</p>

<ul>
  <li>Identifiers with <strong>no linkage</strong> mean the identifier only refers to itself. This includes:
    <ul>
      <li>Normal local variables</li>
      <li>User-defined types, such as enums, typedefs, and classes declared inside a block (we’ll cover these in later lessons).</li>
    </ul>
  </li>
  <li>Identifiers with <strong>internal linkage</strong> can be accessed anywhere within the file it is declared. This includes:
    <ul>
      <li>Static global variables (initialized or uninitialized)</li>
      <li>Const global variables</li>
      <li>Static functions (we’ll cover these in chapter 7)</li>
    </ul>
  </li>
  <li>Identifiers with <strong>external linkage</strong> can be accessed anywhere within the file it is declared, or other files. This includes:
    <ul>
      <li>Normal functions</li>
      <li>Non-const global variables (initialized or uninitialized)</li>
      <li>Extern const global variables</li>
      <li>User-defined types, such as enums, typedefs, and classes declared in the global scope (we’ll cover these in later lessons).</li>
    </ul>
  </li>
</ul>

<p>You can use a forward declaration to access a function in another file.</p>

<p>You can use the extern keyword to access a variable with external linkage in another file.</p>

<p><strong>Variable scope, duration, and linkage summary</strong></p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Example</th>
      <th>Scope</th>
      <th>Duration</th>
      <th>Linkage</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Local variable</td>
      <td>int x;</td>
      <td>Block scope</td>
      <td>Automatic duratio</td>
      <td>No linkage</td>
      <td> </td>
    </tr>
    <tr>
      <td>Static local variable</td>
      <td>static int x;</td>
      <td>Block scope</td>
      <td>Static duration</td>
      <td>No linkage</td>
      <td> </td>
    </tr>
    <tr>
      <td>Dynamic variable</td>
      <td>int *x = new int;</td>
      <td>Block scope</td>
      <td>Dynamic duration</td>
      <td>No linkage</td>
      <td> </td>
    </tr>
    <tr>
      <td>Function parameter</td>
      <td>void foo(int x)</td>
      <td>Block scope</td>
      <td>Automatic duration</td>
      <td>No linkage</td>
      <td> </td>
    </tr>
    <tr>
      <td>Non-const global variable</td>
      <td>int g_x;</td>
      <td>File scope</td>
      <td>Static duration</td>
      <td>External linkage</td>
      <td>Initialized or uninitialized</td>
    </tr>
    <tr>
      <td>Static global variable</td>
      <td>static int g_x;</td>
      <td>File scope</td>
      <td>Static duration</td>
      <td>Internal linkage</td>
      <td>Initialized or uninitialized</td>
    </tr>
    <tr>
      <td>Const global variable</td>
      <td>const int g_x(1);</td>
      <td>File scope</td>
      <td>Static duration</td>
      <td>Internal linkage</td>
      <td> </td>
    </tr>
    <tr>
      <td>Extern const global variable</td>
      <td>extern const int g_x(1);</td>
      <td>File scope</td>
      <td>Static duration</td>
      <td>External linkage</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><strong>Namespaces</strong></p>

<p>In order to help avoid issues where two independent pieces of code have naming collisions with each other when used together, C++ allows us to declare our own namespaces via the <strong>namespace</strong> keyword. Anything declared inside a user-defined namespace belongs to that namespace, not the global namespace.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>namespace Foo
{
    // This doSomething() belongs to namespace Foo
    int doSomething(int x, int y)
    {
        return x + y;
    }
}
</code></pre>
</div>

<p>Accessing a namespace with the scope resolution operator (::)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main(void)
{
    std::cout &lt;&lt; Foo::doSomething(4, 3);
    return 0;
}
</code></pre>
</div>

<p><strong>The using keyword</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main(void)
{
    using namespace Foo; // look in namespace Foo
    std::cout &lt;&lt; doSomething(4, 3) &lt;&lt; std::endl; // calls Foo::doSomething()
    return 0;
}
</code></pre>
</div>

<p><strong>Multiple namespace blocks with the same name allowed</strong></p>

<p>It’s legal to declare namespace blocks in multiple locations (even multiple times in the same file, if you can find a good reason for doing so). All declarations within the namespace block are considered part of the namespace.</p>

<p><strong>Nested namespaces and namespace aliases</strong></p>

<h2 id="implicit-type-conversion-coercion">Implicit type conversion (coercion)</h2>

<p>The process of converting a value from one data type to another is called a <strong>type conversion</strong>.</p>

<p><strong>Implicit type conversion</strong></p>

<p>Implicit type conversion (also called automatic type conversion or coercion) is performed whenever one fundamental data type is expected, but a different fundamental data type is supplied, and the user does not explicitly tell the compiler how to perform this conversion (via a cast).</p>

<p>There are two basic types of implicit type conversion: promotions and conversions.</p>

<p><strong>Numeric promotion</strong></p>

<p>Whenever a value from one type is converted into a value of a larger similar data type, this is called a <strong>numeric promotion</strong> (or <strong>widening</strong>)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>long l(64); // widen the integer 64 into a long
double d(0.12f); // promote the float 0.12 into a double
</code></pre>
</div>

<ul>
  <li><strong>Integral promotion</strong> involves the conversion of integer types narrower than int (which includes bool, char, unsigned char, signed char, unsigned short, signed short) to an integer (if possible) or an unsigned int.</li>
  <li><strong>Floating point promotion</strong> involves the conversion of a float to a double.</li>
</ul>

<p><strong>Numeric conversions</strong></p>

<p>When we convert a value from a larger type to a similar smaller type, or between different types, this is called a <strong>numeric conversion</strong>.</p>

<p>If operands of mixed types are used, the compiler will implicitly convert one operand to agree with the other using a process called <strong>usual arithmetic conversion</strong>. To do this, it uses the following rules:</p>

<ul>
  <li>
    <p>If the operand is an integer, it undergoes integral promotion (as described above).</p>
  </li>
  <li>
    <p>If the operands still do not match, then the compiler finds the highest priority operand and converts the other operand to match.</p>
  </li>
</ul>

<p>The priority of operands is as follows:</p>

<ul>
  <li>long double (highest)</li>
  <li>double</li>
  <li>float</li>
  <li>unsigned long long</li>
  <li>long long</li>
  <li>unsigned long</li>
  <li>long</li>
  <li>unsigned int</li>
  <li>int (lowest)</li>
</ul>

<p><code class="highlighter-rouge">typeid.name()</code></p>

<p><strong>Explicit type conversion (casting)</strong></p>

<p>A <strong>cast</strong> represents an explicit request by the programmer to do a type conversion.</p>

<p>5 different types of casts: C-style casts, static casts, const casts, dynamic casts, and reinterpret casts.</p>

<p><strong>C-style casts</strong></p>

<p>casts are done via the () operator, with the name of the type to cast to inside.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int i1 = 10;
int i2 = 4;
float f = (float)i1 / i2;
</code></pre>
</div>

<p>Because C-style casts are not checked by the compiler at compile time, C-style casts can be inherently misused, because they will let you do things that may not make sense, such as getting rid of a const or changing a data type without changing the underlying representation (leading to garbage results).</p>

<p>Rule: Avoid C-style casts</p>

<p><strong>static_cast</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>int i1 = 10;
int i2 = 4;
float f = static_cast&lt;float&gt;(i1) / i2;
</code></pre>
</div>

<p>The main advantage of static_cast is that it provides compile-time type checking, making it harder to make an inadvertent error. Static_cast is also (intentionally) less powerful than C-style casts, so you can’t inadvertently remove const or do other things you may not have intended to do.</p>

<p>Casting should be avoided if at all possible, because any time a cast is used, there is potential for trouble. But there are many times when it can not be avoided. In most of these cases, the C++ static_cast should be used instead of the C-style cast.</p>

<p><strong>std::string</strong></p>

<p>a collection of sequential characters called a <strong>string</strong></p>

<p><strong>std::getline()</strong></p>

<p>To read a full line of input into a string, you’re better off using the std::getline() function instead. std::getline() takes two parameters: the first is std::cin, and the second is your string variable.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>std::getline(std::cin, age);
</code></pre>
</div>

<p>Rule: If reading numeric values with std::cin, it’s a good idea to remove the extraneous newline using std::cin.ignore().</p>

<div class="highlighter-rouge"><pre class="highlight"><code>std::cin.ignore(32767, '\n');
</code></pre>
</div>

<h2 id="enumerated-types">Enumerated types</h2>

<p>An <strong>enumerated type</strong> (also called an <strong>enumeration</strong>) is a data type where every possible value is defined as a symbolic constant (called an <strong>enumerator</strong>). Enumerations are declared via the <strong>enum</strong> keyword.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="sr">//</span> <span class="no">Declare</span> <span class="n">a</span> <span class="kp">new</span> <span class="n">enumeration</span> <span class="n">named</span> <span class="no">Color</span>
    <span class="n">enum</span> <span class="no">Color</span>
    <span class="p">{</span>
        <span class="sr">//</span> <span class="no">Here</span> <span class="n">are</span> <span class="n">the</span> <span class="n">enumerators</span>
        <span class="sr">//</span> <span class="no">These</span> <span class="n">define</span> <span class="n">all</span> <span class="n">the</span> <span class="n">possible</span> <span class="n">values</span> <span class="n">this</span> <span class="n">type</span> <span class="n">can</span> <span class="n">hold</span>
        <span class="sr">//</span> <span class="no">Each</span> <span class="n">enumerator</span> <span class="n">is</span> <span class="n">separated</span> <span class="n">by</span> <span class="n">a</span> <span class="n">comma</span><span class="p">,</span> <span class="n">not</span> <span class="n">a</span> <span class="n">semicolon</span>
        <span class="no">COLOR_BLACK</span><span class="p">,</span>
        <span class="no">COLOR_RED</span><span class="p">,</span>
        <span class="no">COLOR_BLUE</span><span class="p">,</span>
        <span class="no">COLOR_GREEN</span><span class="p">,</span>
        <span class="no">COLOR_WHITE</span><span class="p">,</span>
        <span class="no">COLOR_CYAN</span><span class="p">,</span>
        <span class="no">COLOR_YELLOW</span><span class="p">,</span>
        <span class="no">COLOR_MAGENTA</span> <span class="sr">//</span> <span class="k">for</span> <span class="n">maximum</span> <span class="n">compatibility</span><span class="p">,</span> <span class="n">the</span> <span class="n">last</span> <span class="n">enumerator</span> <span class="n">should</span> <span class="n">not</span> <span class="n">have</span> <span class="n">a</span> <span class="n">comma</span>
    <span class="p">};</span> <span class="sr">//</span> <span class="n">however</span> <span class="n">the</span> <span class="n">enum</span> <span class="n">itself</span> <span class="n">must</span> <span class="k">end</span> <span class="n">with</span> <span class="n">a</span> <span class="n">semicolon</span>

    <span class="sr">//</span> <span class="no">Define</span> <span class="n">a</span> <span class="n">few</span> <span class="n">variables</span> <span class="n">of</span> <span class="n">enumerated</span> <span class="n">type</span> <span class="no">Color</span>
    <span class="no">Color</span> <span class="n">paint</span> <span class="o">=</span> <span class="no">COLOR_WHITE</span><span class="p">;</span>
    <span class="no">Color</span> <span class="n">house</span><span class="p">(</span><span class="no">COLOR_BLUE</span><span class="p">);</span>
    </code></pre></figure>

<p>it’s common to prefix enumerators with a standard prefix like ANIMAL_ or COLOR_, both to prevent naming conflicts and for code documentation purposes.</p>

<p>Best practice: Don’t assign specific values to your enumerators.</p>

<p>Rule: Don’t assign the same value to two enumerators in the same enumeration unless there’s a very good reason.</p>

<p>C++11 defines a new concept, the <strong>enum class</strong> (also called a <strong>scoped enumeration</strong>), which makes enumerations both strongly typed and strongly scoped. To make an enum class, we use the keyword class after the enum keyword.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="c1">#include &lt;iostream&gt;</span>
    <span class="n">int</span> <span class="n">main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">enum</span> <span class="k">class</span> <span class="nc">Color</span>
        <span class="p">{</span>
            <span class="no">RED</span><span class="p">,</span>
            <span class="no">BLUE</span>
        <span class="p">};</span>

        <span class="no">Color</span> <span class="n">color</span> <span class="o">=</span> <span class="no">Color</span><span class="o">::</span><span class="no">BLUE</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">color</span><span class="p">;</span> <span class="sr">//</span> <span class="n">won</span><span class="s1">'t work, because there'</span><span class="n">s</span> <span class="n">no</span> <span class="n">implicit</span> <span class="n">conversion</span> <span class="n">to</span> <span class="n">int</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">color</span><span class="p">);</span> <span class="sr">//</span> <span class="n">will</span> <span class="nb">print</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    </code></pre></figure>

<h2 id="typedefs">Typedefs</h2>

<p><strong>Typedefs</strong> allow the programmer to create an alias for a data type, and use the aliased name instead of the actual type name.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef double distance_t; // define distance_t as an alias for type double

// The following two statements are equivalent:
double howFar;
distance_t howFar;
</code></pre>
</div>

<p>typedef names are declared using a “_t” suffix. This helps indicate that they are types, not variables, and also helps prevent naming collisions with similarly named variables.</p>

<p>Using typedefs for legibility</p>

<p>Using typedefs for easier code maintenance</p>

<p>Platform independent coding</p>

<p>Using typedefs to make complex types simple</p>

<p>Rule: Use the using version of typedef instead of the typedef keyword if you compiler is C++11 compatible.</p>

<h2 id="structs">Structs</h2>

<p>An <strong>aggregate data</strong> type is a data type that groups multiple individual variables together. One of the simplest aggregate data type is the struct.</p>

<p>A <strong>struct</strong> (short for structure) allows us to group variables of mixed data types together into a single unit.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct Employee
{
    short id;
    int age;
    double wage;
};
</code></pre>
</div>

<p>In order to access the individual members, we use the <strong>member selection operator</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>Employee joe; // create an Employee struct for Joe
joe.id = 14; // assign a value to member id within struct joe
</code></pre>
</div>

<p>Initializing structs by assigning values member by member is a little cumbersome, so C++ supports a faster way to initialize structs using an <strong>initializer list</strong>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Employee joe = { 1, 32, 60000.0 };
</code></pre>
</div>

<p><strong>Non-static member initialization</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct Triangle
{
    double length = 1.0;
    double width = 1.0;
};
</code></pre>
</div>

<h2 id="the-auto-keyword">The auto keyword</h2>

<p>The auto keyword was a way to explicitly specify that a variable should have automatic duration:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int main()
{
    auto int foo(5); // explicitly specify that foo should have automatic duration

    return 0;
}
</code></pre>
</div>

<p>When initializing a variable, the auto keyword can be used in place of the variable type to tell the compiler to infer the variable’s type from the assignment’s type. This is called <strong>automatic type deduction</strong>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>auto d = 5.0; // 5.0 is a double literal, so d will be type double
auto i = 1 + 2; // 1 + 2 evaluates to an integer, so i will be type int
</code></pre>
</div>

<p><strong>Automatic type deduction for functions in C++14</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>auto add(int x, int y)
{
    return x + y;
}
</code></pre>
</div>

<p><strong>trailing return syntax</strong> where the return type is specified after the rest of the function prototype.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>auto add(int x, int y) -&gt; int;
</code></pre>
</div>

<p>Starting with C++11, the auto keyword can be used in place of a variable’s type when doing an initialization in order to perform automatic type deduction.</p>

<p>Other uses of the auto keyword should generally be avoided except on an as-needed basis.</p>

<h2 id="quick-review">Quick review</h2>

<p>A block of statements (aka. a compound statement) is treated by the compiler as if it were a single statement. These are placed between curly brackets ({ and }) and used pretty much everywhere.</p>

<p>Local variables are created when the block they are part of is entered, and destroyed when it is exited. They can only be accessed inside the block in which they are declared.</p>

<p>Global variables are created when the program starts, and are destroyed when it ends. They can be used anywhere in the program. Non-const global variables should generally be avoided because they are evil.</p>

<p>The static keyword can be used to give a global variable internal linkage, so it can only be used in the file in which it is declared. It can also be used to give a local variable static duration, which means the local variable retains its value, even after it goes out of scope.</p>

<p>Namespaces are an area in which all names are guaranteed to be unique. Use of namespace is a great way to avoid naming collisions. Avoid use of “using statements” outside of functions.</p>

<p>Implicit type conversion happens when one type is converted into another type without using a cast. Explicit type conversion happens when one type is converted to another using a cast. In some cases, this is totally safe, and in others, data may be lost. Avoid C-style casts and use static_cast instead.</p>

<p>std::string offers an easy way to deal with text strings. Strings are always placed between double quotes.</p>

<p>Enumerated types let us define our own type where all of the possible values are enumerated. These are great for categorizing things. Enum classes work like enums but offer more type safety, and should be used instead of standard enums if your compiler is C++11 capable.</p>

<p>Typedefs allow us to create an alias for a type’s name. Fixed width integers are implemented using typedefs. Typedefs are useful for giving simple names to complicated types.</p>

<p>And finally, structs offer us a way to group related variables into a single structure and access them using the member selection operator (.). Object-oriented programming builds heavily on top of these, so if you learn one thing from this chapter, make sure it’s this one.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <p>Yanling's fun time with computer graphics and programming related.
</p>
          <p><a class="rss-link" href="http://yanlinghe.com">Main Site </a></p>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/heyl0822"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">heyl0822</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/heyl0822"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">heyl0822</span></a>

          </li>
          
			
			
          <li><a class="email-link" href="mailto:h@yanlinghe.com">h@yanlinghe.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p class="rss-subscribe">subscribe <a class="rss-link" href="/_site/feed.xml">via RSS</a></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
